/*
 * MIND API
 *
 * This is the Master Inventory Network Database (MIND) API. MIND provides automated allocation of technical attributes needed to create IP and Ethernet VPNs on the global Sigma network. MIND supports the 'Nova' services specfication which defines the collection of connectivity services supported by ENT. Go to https://thehub.thomsonreuters.com/docs/DOC-2193014 to learn more.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jonathan.beasley@thomsonreuters.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Mind.Api.Models
{ 
    /// <summary>
    /// Model for requesting tenant attachment to the provider domain
    /// </summary>
    [DataContract]
    public partial class ProviderDomainAttachmentRequest : IEquatable<ProviderDomainAttachmentRequest>
    { 
        /// <summary>
        /// Determines if the attachment is enabled for layer 3
        /// </summary>
        /// <value>Determines if the attachment is enabled for layer 3</value>
        [DataMember(Name="isLayer3")]
        public bool? IsLayer3 { get; set; }

        /// <summary>
        /// Determines if a bundle style of attachment is required
        /// </summary>
        /// <value>Determines if a bundle style of attachment is required</value>
        [DataMember(Name="bundleRequired")]
        public bool? BundleRequired { get; set; }

        /// <summary>
        /// Determines if a multi port style of attachment is required
        /// </summary>
        /// <value>Determines if a multi port style of attachment is required</value>
        [DataMember(Name="multiportRequired")]
        public bool? MultiportRequired { get; set; }

        /// <summary>
        /// Determines if the attachment should be enabled for tagging
        /// </summary>
        /// <value>Determines if the attachment should be enabled for tagging</value>
        [DataMember(Name="isTagged")]
        public bool? IsTagged { get; set; }

        /// <summary>
        /// The name of a provider network location within which the new attachment will be provisioned
        /// </summary>
        /// <value>The name of a provider network location within which the new attachment will be provisioned</value>
        [Required]
        [DataMember(Name="locationName")]
        public string LocationName { get; set; }

        /// <summary>
        /// The name of a port pool which ports for the new attachment will be allocated from
        /// </summary>
        /// <value>The name of a port pool</value>
        [Required]
        [DataMember(Name = "portPoolName")]
        public string PortPoolName { get; set; }

        /// <summary>
        /// The name of an attachment role which sets certain constrains on how the attachment must be configuted
        /// </summary>
        /// <value>The name of an attachment role</value>
        [Required]
        [DataMember(Name = "attachmentRoleName")]
        public string AttachmentRoleName { get; set; }

        /// <summary>
        /// Optional name of the provider network plane within which the attachment will be provisioned
        /// </summary>
        /// <value>Optional name of the provider network plane within which the attachment will be provisioned</value>
        public enum PlaneNameEnum
        { 
            /// <summary>
            /// Enum RedEnum for Red
            /// </summary>
            [EnumMember(Value = "Red")]
            RedEnum = 1,
            
            /// <summary>
            /// Enum BlueEnum for Blue
            /// </summary>
            [EnumMember(Value = "Blue")]
            BlueEnum = 2
        }

        /// <summary>
        /// Optional name of the provider network plane within which the attachment will be provisioned
        /// </summary>
        /// <value>Optional name of the provider network plane within which the attachment will be provisioned</value>
        [DataMember(Name="planeName")]
        public PlaneNameEnum? PlaneName { get; set; }

        /// <summary>
        /// The required bandwidth of the attachment in Gbps
        /// </summary>
        /// <value>The required bandwidth of the attachment in Gbps</value>
        [DataMember(Name="attachmentBandwidthGbps")]
        public int? AttachmentBandwidthGbps { get; set; }

        /// <summary>
        /// The required contract bandwidth in Mbps
        /// </summary>
        /// <value>The required contract bandwidth in Mbps</value>
        [DataMember(Name="contractBandwidthMbps")]
        public int? ContractBandwidthMbps { get; set; }

        /// <summary>
        /// Determines whether DSCP and COS markings of packets sent from the tenant network should be trusted by the provider
        /// </summary>
        /// <value>Determines whether DSCP and COS markings of packets sent from the tenant network should be trusted by the provider</value>
        [DataMember(Name="trustReceivedCosDscp")]
        public bool? TrustReceivedCosDscp { get; set; }

        /// <summary>
        /// IPv4 address assigned to the first connection in the attachment
        /// </summary>
        /// <value>IPv4 address assigned to the first connection in the attachment</value>
        [DataMember(Name="IpAddress1")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid IP address must be entered, e.g. 192.168.0.1")]
        public string IpAddress1 { get; set; }

        /// <summary>
        /// IPv4 subnet mask assigned to the first connection in the attachment
        /// </summary>
        /// <value>IPv4 subnet mask assigned to the first connection in the attachment</value>
        [DataMember(Name="SubnetMask1")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid subnet mask must be entered, e.g. 255.255.255.252")]
        public string SubnetMask1 { get; set; }

        /// <summary>
        /// IPv4 address assigned to the second connection in the attachment
        /// </summary>
        /// <value>IPv4 address assigned to the second connection in the attachment</value>
        [DataMember(Name="IpAddress2")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid IP address must be entered, e.g. 192.168.0.1")]
        public string IpAddress2 { get; set; }

        /// <summary>
        /// IPv4 subnet mask assigned to the second connection in the attachment
        /// </summary>
        /// <value>IPv4 subnet mask assigned to the second connection in the attachment</value>
        [DataMember(Name="SubnetMask2")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid subnet mask must be entered, e.g. 255.255.255.252")]
        public string SubnetMask2 { get; set; }

        /// <summary>
        /// IPv4 address assigned to the third connection in the attachment
        /// </summary>
        /// <value>IPv4 address assigned to the third connection in the attachment</value>
        [DataMember(Name="IpAddress3")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid IP address must be entered, e.g. 192.168.0.1")]
        public string IpAddress3 { get; set; }

        /// <summary>
        /// IPv4 subnet mask assigned to the third connection in the attachment
        /// </summary>
        /// <value>IPv4 subnet mask assigned to the third connection in the attachment</value>
        [DataMember(Name="SubnetMask3")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid subnet mask must be entered, e.g. 255.255.255.252")]
        public string SubnetMask3 { get; set; }

        /// <summary>
        /// IPv4 address assigned to the fourth connection in the attachment
        /// </summary>
        /// <value>IPv4 address assigned to the fourth connection in the attachment</value>
        [DataMember(Name="IpAddress4")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid IP address must be entered, e.g. 192.168.0.1")]
        public string IpAddress4 { get; set; }

        /// <summary>
        /// IPv4 subnet mask assigned to the fourth connection in the attachment
        /// </summary>
        /// <value>IPv4 subnet mask assigned to the fourth connection in the attachment</value>
        [DataMember(Name="SubnetMask4")]
        [RegularExpression(@"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
            ErrorMessage = "A valid subnet mask must be entered, e.g. 255.255.255.252")]
        public string SubnetMask4 { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TenantAttachmentRequest {\n");
            sb.Append("  IsLayer3: ").Append(IsLayer3).Append("\n");
            sb.Append("  BundleRequired: ").Append(BundleRequired).Append("\n");
            sb.Append("  MultiportRequired: ").Append(MultiportRequired).Append("\n");
            sb.Append("  IsTagged: ").Append(IsTagged).Append("\n");
            sb.Append("  LocationName: ").Append(LocationName).Append("\n");
            sb.Append("  PortPoolName: ").Append(PortPoolName).Append("\n");
            sb.Append("  AttachmentRoleName: ").Append(AttachmentRoleName).Append("\n");
            sb.Append("  PlaneName: ").Append(PlaneName).Append("\n");
            sb.Append("  AttachmentBandwidthGbps: ").Append(AttachmentBandwidthGbps).Append("\n");
            sb.Append("  ContractBandwidthMbps: ").Append(ContractBandwidthMbps).Append("\n");
            sb.Append("  TrustReceivedCosDscp: ").Append(TrustReceivedCosDscp).Append("\n");
            sb.Append("  IpAddress1: ").Append(IpAddress1).Append("\n");
            sb.Append("  SubnetMask1: ").Append(SubnetMask1).Append("\n");
            sb.Append("  IpAddress2: ").Append(IpAddress2).Append("\n");
            sb.Append("  SubnetMask2: ").Append(SubnetMask2).Append("\n");
            sb.Append("  IpAddress3: ").Append(IpAddress3).Append("\n");
            sb.Append("  SubnetMask3: ").Append(SubnetMask3).Append("\n");
            sb.Append("  IpAddress4: ").Append(IpAddress4).Append("\n");
            sb.Append("  SubnetMask4: ").Append(SubnetMask4).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((ProviderDomainAttachmentRequest)obj);
        }

        /// <summary>
        /// Returns true if TenantAttachmentRequest instances are equal
        /// </summary>
        /// <param name="other">Instance of TenantAttachmentRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ProviderDomainAttachmentRequest other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    IsLayer3 == other.IsLayer3 ||
                    IsLayer3 != null &&
                    IsLayer3.Equals(other.IsLayer3)
                ) && 
                (
                    BundleRequired == other.BundleRequired ||
                    BundleRequired != null &&
                    BundleRequired.Equals(other.BundleRequired)
                ) && 
                (
                    MultiportRequired == other.MultiportRequired ||
                    MultiportRequired != null &&
                    MultiportRequired.Equals(other.MultiportRequired)
                ) && 
                (
                    IsTagged == other.IsTagged ||
                    IsTagged != null &&
                    IsTagged.Equals(other.IsTagged)
                ) && 
                (
                    LocationName == other.LocationName ||
                    LocationName != null &&
                    LocationName.Equals(other.LocationName)
                ) &&
                                (
                    PortPoolName == other.PortPoolName ||
                    PortPoolName != null &&
                    PortPoolName.Equals(other.PortPoolName)
                ) &&
                                (
                    AttachmentRoleName == other.AttachmentRoleName ||
                    AttachmentRoleName != null &&
                    AttachmentRoleName.Equals(other.AttachmentRoleName)
                ) &&
                (
                    PlaneName == other.PlaneName ||
                    PlaneName != null &&
                    PlaneName.Equals(other.PlaneName)
                ) && 
                (
                    AttachmentBandwidthGbps == other.AttachmentBandwidthGbps ||
                    AttachmentBandwidthGbps != null &&
                    AttachmentBandwidthGbps.Equals(other.AttachmentBandwidthGbps)
                ) && 
                (
                    ContractBandwidthMbps == other.ContractBandwidthMbps ||
                    ContractBandwidthMbps != null &&
                    ContractBandwidthMbps.Equals(other.ContractBandwidthMbps)
                ) && 
                (
                    TrustReceivedCosDscp == other.TrustReceivedCosDscp ||
                    TrustReceivedCosDscp != null &&
                    TrustReceivedCosDscp.Equals(other.TrustReceivedCosDscp)
                ) && 
                (
                    IpAddress1 == other.IpAddress1 ||
                    IpAddress1 != null &&
                    IpAddress1.Equals(other.IpAddress1)
                ) && 
                (
                    SubnetMask1 == other.SubnetMask1 ||
                    SubnetMask1 != null &&
                    SubnetMask1.Equals(other.SubnetMask1)
                ) && 
                (
                    IpAddress2 == other.IpAddress2 ||
                    IpAddress2 != null &&
                    IpAddress2.Equals(other.IpAddress2)
                ) && 
                (
                    SubnetMask2 == other.SubnetMask2 ||
                    SubnetMask2 != null &&
                    SubnetMask2.Equals(other.SubnetMask2)
                ) && 
                (
                    IpAddress3 == other.IpAddress3 ||
                    IpAddress3 != null &&
                    IpAddress3.Equals(other.IpAddress3)
                ) && 
                (
                    SubnetMask3 == other.SubnetMask3 ||
                    SubnetMask3 != null &&
                    SubnetMask3.Equals(other.SubnetMask3)
                ) && 
                (
                    IpAddress4 == other.IpAddress4 ||
                    IpAddress4 != null &&
                    IpAddress4.Equals(other.IpAddress4)
                ) && 
                (
                    SubnetMask4 == other.SubnetMask4 ||
                    SubnetMask4 != null &&
                    SubnetMask4.Equals(other.SubnetMask4)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (IsLayer3 != null)
                    hashCode = hashCode * 59 + IsLayer3.GetHashCode();
                    if (BundleRequired != null)
                    hashCode = hashCode * 59 + BundleRequired.GetHashCode();
                    if (MultiportRequired != null)
                    hashCode = hashCode * 59 + MultiportRequired.GetHashCode();
                    if (IsTagged != null)
                    hashCode = hashCode * 59 + IsTagged.GetHashCode();
                    if (LocationName != null)
                    hashCode = hashCode * 59 + LocationName.GetHashCode();
                    if (PortPoolName != null)
                    hashCode = hashCode * 59 + PortPoolName.GetHashCode();
                    if (AttachmentRoleName != null)
                    hashCode = hashCode * 59 + AttachmentRoleName.GetHashCode();
                    if (PlaneName != null)
                    hashCode = hashCode * 59 + PlaneName.GetHashCode();
                    if (AttachmentBandwidthGbps != null)
                    hashCode = hashCode * 59 + AttachmentBandwidthGbps.GetHashCode();
                    if (ContractBandwidthMbps != null)
                    hashCode = hashCode * 59 + ContractBandwidthMbps.GetHashCode();
                    if (TrustReceivedCosDscp != null)
                    hashCode = hashCode * 59 + TrustReceivedCosDscp.GetHashCode();
                    if (IpAddress1 != null)
                    hashCode = hashCode * 59 + IpAddress1.GetHashCode();
                    if (SubnetMask1 != null)
                    hashCode = hashCode * 59 + SubnetMask1.GetHashCode();
                    if (IpAddress2 != null)
                    hashCode = hashCode * 59 + IpAddress2.GetHashCode();
                    if (SubnetMask2 != null)
                    hashCode = hashCode * 59 + SubnetMask2.GetHashCode();
                    if (IpAddress3 != null)
                    hashCode = hashCode * 59 + IpAddress3.GetHashCode();
                    if (SubnetMask3 != null)
                    hashCode = hashCode * 59 + SubnetMask3.GetHashCode();
                    if (IpAddress4 != null)
                    hashCode = hashCode * 59 + IpAddress4.GetHashCode();
                    if (SubnetMask4 != null)
                    hashCode = hashCode * 59 + SubnetMask4.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(ProviderDomainAttachmentRequest left, ProviderDomainAttachmentRequest right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ProviderDomainAttachmentRequest left, ProviderDomainAttachmentRequest right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
