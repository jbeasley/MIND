/*
 * MIND API
 *
 * This is the Master Inventory Network Database (MIND) API. MIND provides automated allocation of technical attributes needed to create IP and Ethernet VPNs on the global Sigma network. MIND supports the 'Nova' services specfication which defines the collection of connectivity services supported by ENT. Go to https://thehub.thomsonreuters.com/docs/DOC-2193014 to learn more.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jonathan.beasley@thomsonreuters.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Mind.Api.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class VpnRequest : IEquatable<VpnRequest>
    { 
        /// <summary>
        /// The name of the VPN
        /// </summary>
        /// <value>The name of the VPN</value>
        [Required]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// A description of the VPN
        /// </summary>
        /// <value>A description of the VPN</value>
        [DataMember(Name="description")]
        public string Description { get; set; }
        /// <summary>
        /// The geographical region which the VPN operates within. If no region is chosen then the VPN is available in all regions
        /// </summary>
        /// <value>The geographical region which the VPN operates within. If no region is chosen then the VPN is available in all regions</value>
        public enum RegionEnum
        { 
            /// <summary>
            /// Enum EMEAEnum for EMEA
            /// </summary>
            [EnumMember(Value = "EMEA")]
            EMEAEnum = 1,
            
            /// <summary>
            /// Enum ASIAPACEnum for ASIAPAC
            /// </summary>
            [EnumMember(Value = "ASIAPAC")]
            ASIAPACEnum = 2,
            
            /// <summary>
            /// Enum AMERSEnum for AMERS
            /// </summary>
            [EnumMember(Value = "AMERS")]
            AMERSEnum = 3
        }

        /// <summary>
        /// The geographical region which the VPN operates within. If no region is chosen then the VPN is available in all regions
        /// </summary>
        /// <value>The geographical region which the VPN operates within. If no region is chosen then the VPN is available in all regions</value>
        [DataMember(Name="region")]
        public RegionEnum? Region { get; set; }
        /// <summary>
        /// The provider plane which the VPN operates within. If no plane is chosen then the VPN will operate in both the red and blue planes.
        /// </summary>
        /// <value>The provider plane which the VPN operates within. If no plane is chosen then the VPN will operate in both the red and blue planes.</value>
        public enum PlaneEnum
        { 
            /// <summary>
            /// Enum RedEnum for Red
            /// </summary>
            [EnumMember(Value = "Red")]
            RedEnum = 1,
            
            /// <summary>
            /// Enum BlueEnum for Blue
            /// </summary>
            [EnumMember(Value = "Blue")]
            BlueEnum = 2
        }

        /// <summary>
        /// The provider plane which the VPN operates within. If no plane is chosen then the VPN will operate in both the red and blue planes.
        /// </summary>
        /// <value>The provider plane which the VPN operates within. If no plane is chosen then the VPN will operate in both the red and blue planes.</value>
        [DataMember(Name="plane")]
        public PlaneEnum? Plane { get; set; }
        /// <summary>
        /// The tenancy type of the VPN. If the tenancy type is single then only the owner of the VPN can participate in the VPN. If the tenancy type is multi then any tenant can participate in the VPN.
        /// </summary>
        /// <value>The tenancy type of the VPN. If the tenancy type is single then only the owner of the VPN can participate in the VPN. If the tenancy type is multi then any tenant can participate in the VPN.</value>
        public enum TenancyTypeEnum
        { 
            /// <summary>
            /// Enum SingleEnum for Single
            /// </summary>
            [EnumMember(Value = "Single")]
            SingleEnum = 1,
            
            /// <summary>
            /// Enum MultiEnum for Multi
            /// </summary>
            [EnumMember(Value = "Multi")]
            MultiEnum = 2
        }

        /// <summary>
        /// The tenancy type of the VPN. If the tenancy type is single then only the owner of the VPN can participate in the VPN. If the tenancy type is multi then any tenant can participate in the VPN.
        /// </summary>
        /// <value>The tenancy type of the VPN. If the tenancy type is single then only the owner of the VPN can participate in the VPN. If the tenancy type is multi then any tenant can participate in the VPN.</value>
        [Required]
        [DataMember(Name="tenancyType")]
        public TenancyTypeEnum? TenancyType { get; set; }
        /// <summary>
        /// The topology type of the VPN. A meshed VPN allows any endpoint to communicate with any other endpoint. A hub-and-spoke VPN allows spoke endpoints to communicate with hub endpoints but not with other spoke endpoints. 
        /// </summary>
        /// <value>The topology type of the VPN. A meshed VPN allows any endpoint to communicate with any other endpoint. A hub-and-spoke VPN allows spoke endpoints to communicate with hub endpoints but not with other spoke endpoints. </value>
        public enum TopologyTypeEnum
        { 
            /// <summary>
            /// Enum MeshedEnum for Meshed
            /// </summary>
            [EnumMember(Value = "Meshed")]
            MeshedEnum = 1,
            
            /// <summary>
            /// Enum HubAndSpokeEnum for Hub-and-Spoke
            /// </summary>
            [EnumMember(Value = "Hub-and-Spoke")]
            HubAndSpokeEnum = 2
        }

        /// <summary>
        /// The topology type of the VPN. A meshed VPN allows any endpoint to communicate with any other endpoint. A hub-and-spoke VPN allows spoke endpoints to communicate with hub endpoints but not with other spoke endpoints. 
        /// </summary>
        /// <value>The topology type of the VPN. A meshed VPN allows any endpoint to communicate with any other endpoint. A hub-and-spoke VPN allows spoke endpoints to communicate with hub endpoints but not with other spoke endpoints. </value>
        [Required]
        [DataMember(Name="topologyType")]
        public TopologyTypeEnum? TopologyType { get; set; }
        /// <summary>
        /// The address family of the VPN. Currently only IPv4 is available. 
        /// </summary>
        /// <value>The address family of the VPN. Currently only IPv4 is available. </value>
        public enum AddressFamilyEnum
        { 
            /// <summary>
            /// Enum IPv4Enum for IPv4
            /// </summary>
            [EnumMember(Value = "IPv4")]
            IPv4Enum = 1
        }

        /// <summary>
        /// The address family of the VPN. Currently only IPv4 is available. 
        /// </summary>
        /// <value>The address family of the VPN. Currently only IPv4 is available. </value>
        [Required]
        [DataMember(Name="addressFamily")]
        public AddressFamilyEnum? AddressFamily { get; set; }

        /// <summary>
        /// Determines if the VPN is launched as a standard Nova implemented VPN. If this option is disabled the VPN may be customised.
        /// </summary>
        /// <value>Determines if the VPN is launched as a standard Nova implemented VPN. If this option is disabled the VPN may be customised.</value>
        [Required]
        [DataMember(Name="isNovaVpn")]
        public bool? IsNovaVpn { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class VpnRequest {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Region: ").Append(Region).Append("\n");
            sb.Append("  Plane: ").Append(Plane).Append("\n");
            sb.Append("  TenancyType: ").Append(TenancyType).Append("\n");
            sb.Append("  TopologyType: ").Append(TopologyType).Append("\n");
            sb.Append("  AddressFamily: ").Append(AddressFamily).Append("\n");
            sb.Append("  IsNovaVpn: ").Append(IsNovaVpn).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((VpnRequest)obj);
        }

        /// <summary>
        /// Returns true if VpnRequest instances are equal
        /// </summary>
        /// <param name="other">Instance of VpnRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VpnRequest other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    Region == other.Region ||
                    Region != null &&
                    Region.Equals(other.Region)
                ) && 
                (
                    Plane == other.Plane ||
                    Plane != null &&
                    Plane.Equals(other.Plane)
                ) && 
                (
                    TenancyType == other.TenancyType ||
                    TenancyType != null &&
                    TenancyType.Equals(other.TenancyType)
                ) && 
                (
                    TopologyType == other.TopologyType ||
                    TopologyType != null &&
                    TopologyType.Equals(other.TopologyType)
                ) && 
                (
                    AddressFamily == other.AddressFamily ||
                    AddressFamily != null &&
                    AddressFamily.Equals(other.AddressFamily)
                ) && 
                (
                    IsNovaVpn == other.IsNovaVpn ||
                    IsNovaVpn != null &&
                    IsNovaVpn.Equals(other.IsNovaVpn)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (Region != null)
                    hashCode = hashCode * 59 + Region.GetHashCode();
                    if (Plane != null)
                    hashCode = hashCode * 59 + Plane.GetHashCode();
                    if (TenancyType != null)
                    hashCode = hashCode * 59 + TenancyType.GetHashCode();
                    if (TopologyType != null)
                    hashCode = hashCode * 59 + TopologyType.GetHashCode();
                    if (AddressFamily != null)
                    hashCode = hashCode * 59 + AddressFamily.GetHashCode();
                    if (IsNovaVpn != null)
                    hashCode = hashCode * 59 + IsNovaVpn.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(VpnRequest left, VpnRequest right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(VpnRequest left, VpnRequest right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
