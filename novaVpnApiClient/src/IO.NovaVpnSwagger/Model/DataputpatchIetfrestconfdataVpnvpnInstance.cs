/* 
 * vpn
 *
 * This module defines the YANG model for Nova IPv4 VPN services. The model can be used to create a swagger API definition using the yanger tool.Written by Jon Beasley - WAN Architecture and Strategy - 2018
 *
 * OpenAPI spec version: 1.0.0.1
 * Contact: jonathan.beasley@refinitiv.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.NovaVpnSwagger.Client.SwaggerDateConverter;

namespace IO.NovaVpnSwagger.Model
{
    /// <summary>
    /// DataputpatchIetfrestconfdataVpnvpnInstance
    /// </summary>
    [DataContract]
    public partial class DataputpatchIetfrestconfdataVpnvpnInstance :  IEquatable<DataputpatchIetfrestconfdataVpnvpnInstance>, IValidatableObject
    {
        /// <summary>
        /// The Protocol Type of the VPN (e.g. IP) (leaf)
        /// </summary>
        /// <value>The Protocol Type of the VPN (e.g. IP) (leaf)</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ProtocolTypeEnum
        {
            
            /// <summary>
            /// Enum IP for value: IP
            /// </summary>
            [EnumMember(Value = "IP")]
            IP = 1,
            
            /// <summary>
            /// Enum Ethernet for value: Ethernet
            /// </summary>
            [EnumMember(Value = "Ethernet")]
            Ethernet = 2
        }

        /// <summary>
        /// The Protocol Type of the VPN (e.g. IP) (leaf)
        /// </summary>
        /// <value>The Protocol Type of the VPN (e.g. IP) (leaf)</value>
        [DataMember(Name="protocol-type", EmitDefaultValue=false)]
        public ProtocolTypeEnum? ProtocolType { get; set; }
        /// <summary>
        /// The address-family of the IP VPN (e.g. IPv4) (leaf)
        /// </summary>
        /// <value>The address-family of the IP VPN (e.g. IPv4) (leaf)</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum AddressFamilyEnum
        {
            
            /// <summary>
            /// Enum IPv4 for value: IPv4
            /// </summary>
            [EnumMember(Value = "IPv4")]
            IPv4 = 1,
            
            /// <summary>
            /// Enum IPv6 for value: IPv6
            /// </summary>
            [EnumMember(Value = "IPv6")]
            IPv6 = 2
        }

        /// <summary>
        /// The address-family of the IP VPN (e.g. IPv4) (leaf)
        /// </summary>
        /// <value>The address-family of the IP VPN (e.g. IPv4) (leaf)</value>
        [DataMember(Name="address-family", EmitDefaultValue=false)]
        public AddressFamilyEnum? AddressFamily { get; set; }
        /// <summary>
        /// The Topology Type of the IP VPN (e.g. any-to-any) (leaf)
        /// </summary>
        /// <value>The Topology Type of the IP VPN (e.g. any-to-any) (leaf)</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TopologyTypeEnum
        {
            
            /// <summary>
            /// Enum AnyToAny for value: Any-to-Any
            /// </summary>
            [EnumMember(Value = "Any-to-Any")]
            AnyToAny = 1,
            
            /// <summary>
            /// Enum HubAndSpoke for value: Hub-and-Spoke
            /// </summary>
            [EnumMember(Value = "Hub-and-Spoke")]
            HubAndSpoke = 2
        }

        /// <summary>
        /// The Topology Type of the IP VPN (e.g. any-to-any) (leaf)
        /// </summary>
        /// <value>The Topology Type of the IP VPN (e.g. any-to-any) (leaf)</value>
        [DataMember(Name="topology-type", EmitDefaultValue=false)]
        public TopologyTypeEnum? TopologyType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DataputpatchIetfrestconfdataVpnvpnInstance" /> class.
        /// </summary>
        /// <param name="name">VPN service name (leaf).</param>
        /// <param name="protocolType">The Protocol Type of the VPN (e.g. IP) (leaf) (default to ProtocolTypeEnum.IP).</param>
        /// <param name="vpnAttachmentSet">VRF membership of the VPN (list).</param>
        /// <param name="addressFamily">The address-family of the IP VPN (e.g. IPv4) (leaf) (default to AddressFamilyEnum.IPv4).</param>
        /// <param name="topologyType">The Topology Type of the IP VPN (e.g. any-to-any) (leaf) (default to TopologyTypeEnum.AnyToAny).</param>
        /// <param name="isExtranet">Determines whether the VPN supports Extranet (leaf).</param>
        /// <param name="routeTargetA">routeTargetA.</param>
        /// <param name="routeTargetB">routeTargetB.</param>
        public DataputpatchIetfrestconfdataVpnvpnInstance(string name = default(string), ProtocolTypeEnum? protocolType = ProtocolTypeEnum.IP, List<DataputpatchIetfrestconfdataVpnvpnVpnattachmentset> vpnAttachmentSet = default(List<DataputpatchIetfrestconfdataVpnvpnVpnattachmentset>), AddressFamilyEnum? addressFamily = AddressFamilyEnum.IPv4, TopologyTypeEnum? topologyType = TopologyTypeEnum.AnyToAny, string isExtranet = default(string), DataVpnVpnInstanceInstancenameRoutetargetAVpnroutetargetA routeTargetA = default(DataVpnVpnInstanceInstancenameRoutetargetAVpnroutetargetA), DataVpnVpnInstanceInstancenameRoutetargetBVpnroutetargetB routeTargetB = default(DataVpnVpnInstanceInstancenameRoutetargetBVpnroutetargetB))
        {
            this.Name = name;
            // use default value if no "protocolType" provided
            if (protocolType == null)
            {
                this.ProtocolType = ProtocolTypeEnum.IP;
            }
            else
            {
                this.ProtocolType = protocolType;
            }
            this.VpnAttachmentSet = vpnAttachmentSet;
            // use default value if no "addressFamily" provided
            if (addressFamily == null)
            {
                this.AddressFamily = AddressFamilyEnum.IPv4;
            }
            else
            {
                this.AddressFamily = addressFamily;
            }
            // use default value if no "topologyType" provided
            if (topologyType == null)
            {
                this.TopologyType = TopologyTypeEnum.AnyToAny;
            }
            else
            {
                this.TopologyType = topologyType;
            }
            this.IsExtranet = isExtranet;
            this.RouteTargetA = routeTargetA;
            this.RouteTargetB = routeTargetB;
        }
        
        /// <summary>
        /// VPN service name (leaf)
        /// </summary>
        /// <value>VPN service name (leaf)</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }


        /// <summary>
        /// VRF membership of the VPN (list)
        /// </summary>
        /// <value>VRF membership of the VPN (list)</value>
        [DataMember(Name="vpn-attachment-set", EmitDefaultValue=false)]
        public List<DataputpatchIetfrestconfdataVpnvpnVpnattachmentset> VpnAttachmentSet { get; set; }



        /// <summary>
        /// Determines whether the VPN supports Extranet (leaf)
        /// </summary>
        /// <value>Determines whether the VPN supports Extranet (leaf)</value>
        [DataMember(Name="is-extranet", EmitDefaultValue=false)]
        public string IsExtranet { get; set; }

        /// <summary>
        /// Gets or Sets RouteTargetA
        /// </summary>
        [DataMember(Name="route-target-A", EmitDefaultValue=false)]
        public DataVpnVpnInstanceInstancenameRoutetargetAVpnroutetargetA RouteTargetA { get; set; }

        /// <summary>
        /// Gets or Sets RouteTargetB
        /// </summary>
        [DataMember(Name="route-target-B", EmitDefaultValue=false)]
        public DataVpnVpnInstanceInstancenameRoutetargetBVpnroutetargetB RouteTargetB { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DataputpatchIetfrestconfdataVpnvpnInstance {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  ProtocolType: ").Append(ProtocolType).Append("\n");
            sb.Append("  VpnAttachmentSet: ").Append(VpnAttachmentSet).Append("\n");
            sb.Append("  AddressFamily: ").Append(AddressFamily).Append("\n");
            sb.Append("  TopologyType: ").Append(TopologyType).Append("\n");
            sb.Append("  IsExtranet: ").Append(IsExtranet).Append("\n");
            sb.Append("  RouteTargetA: ").Append(RouteTargetA).Append("\n");
            sb.Append("  RouteTargetB: ").Append(RouteTargetB).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DataputpatchIetfrestconfdataVpnvpnInstance);
        }

        /// <summary>
        /// Returns true if DataputpatchIetfrestconfdataVpnvpnInstance instances are equal
        /// </summary>
        /// <param name="input">Instance of DataputpatchIetfrestconfdataVpnvpnInstance to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DataputpatchIetfrestconfdataVpnvpnInstance input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.ProtocolType == input.ProtocolType ||
                    (this.ProtocolType != null &&
                    this.ProtocolType.Equals(input.ProtocolType))
                ) && 
                (
                    this.VpnAttachmentSet == input.VpnAttachmentSet ||
                    this.VpnAttachmentSet != null &&
                    this.VpnAttachmentSet.SequenceEqual(input.VpnAttachmentSet)
                ) && 
                (
                    this.AddressFamily == input.AddressFamily ||
                    (this.AddressFamily != null &&
                    this.AddressFamily.Equals(input.AddressFamily))
                ) && 
                (
                    this.TopologyType == input.TopologyType ||
                    (this.TopologyType != null &&
                    this.TopologyType.Equals(input.TopologyType))
                ) && 
                (
                    this.IsExtranet == input.IsExtranet ||
                    (this.IsExtranet != null &&
                    this.IsExtranet.Equals(input.IsExtranet))
                ) && 
                (
                    this.RouteTargetA == input.RouteTargetA ||
                    (this.RouteTargetA != null &&
                    this.RouteTargetA.Equals(input.RouteTargetA))
                ) && 
                (
                    this.RouteTargetB == input.RouteTargetB ||
                    (this.RouteTargetB != null &&
                    this.RouteTargetB.Equals(input.RouteTargetB))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.ProtocolType != null)
                    hashCode = hashCode * 59 + this.ProtocolType.GetHashCode();
                if (this.VpnAttachmentSet != null)
                    hashCode = hashCode * 59 + this.VpnAttachmentSet.GetHashCode();
                if (this.AddressFamily != null)
                    hashCode = hashCode * 59 + this.AddressFamily.GetHashCode();
                if (this.TopologyType != null)
                    hashCode = hashCode * 59 + this.TopologyType.GetHashCode();
                if (this.IsExtranet != null)
                    hashCode = hashCode * 59 + this.IsExtranet.GetHashCode();
                if (this.RouteTargetA != null)
                    hashCode = hashCode * 59 + this.RouteTargetA.GetHashCode();
                if (this.RouteTargetB != null)
                    hashCode = hashCode * 59 + this.RouteTargetB.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
